// MatchupOdds.v3.tsx
// No hardcoded first-possession edge.
// Any edge must come from the backend model.
// Endpoints + queryKey remain intact.

import { useQuery } from "@tanstack/react-query";
import { Card, CardContent } from "@/components/ui/card";
import { Skeleton } from "@/components/ui/skeleton";
import type { Profile } from "@shared/schema";

interface MatchupLine {
  spread: number;              // pre-coin-toss, player1 margin
  moneylineA: number;
  moneylineB: number;
  total: number;
  expectedMargin: number;
  pA: number;
  pB: number;

  // Optional, model-derived
  firstPossessionEdge?: number | null;
}

interface MatchupOddsProps {
  player1: Profile;
  player2: Profile;

  // 1 = player1 receives
  // 2 = player2 receives
  // null/undefined = pre-toss
  firstPossession?: number | null;
}

function formatMoneyline(odds: number): string {
  return odds > 0 ? `+${odds}` : `${odds}`;
}

function roundToHalf(x: number): number {
  return Math.round(x * 2) / 2;
}

/**
 * Spread sign convention:
 * spread < 0 => player1 favored
 * spread > 0 => player2 favored
 */
function formatSpread(spread: number, p1: string, p2: string): string {
  if (!Number.isFinite(spread)) return "â€”";
  if (Math.abs(spread) < 0.001) return "PK";

  const favored = spread < 0 ? p1 : p2;
  return `${favored.slice(0, 10)} -${Math.abs(spread).toFixed(1)}`;
}

export default function MatchupOddsV3({
  player1,
  player2,
  firstPossession,
}: MatchupOddsProps) {
  const firstPossessionId =
    firstPossession === 1
      ? player1.id
      : firstPossession === 2
      ? player2.id
      : null;

  const { data: line, isLoading } = useQuery<MatchupLine>({
    queryKey: ["/api/matchup-line", player1.id, player2.id, firstPossessionId],
  });

  if (isLoading) {
    return (
      <Card className="bg-gradient-to-r from-[#1b0f32] to-[#132654] border-0">
        <CardContent className="py-3 px-4">
          <div className="flex items-center justify-center gap-8">
            <Skeleton className="h-10 w-24 bg-white/10" />
            <Skeleton className="h-10 w-32 bg-white/10" />
            <Skeleton className="h-10 w-24 bg-white/10" />
          </div>
        </CardContent>
      </Card>
    );
  }

  if (!line) return null;

  // ---------- PRE-COIN-TOSS ----------
  const neutralSpread = roundToHalf(line.spread);
  const neutralDisplay = formatSpread(neutralSpread, player1.name, player2.name);

  // ---------- POST-COIN-TOSS (MODEL-DRIVEN ONLY) ----------
  const hasCoinToss = firstPossession === 1 || firstPossession === 2;
  const edge = line.firstPossessionEdge ?? 0;

  let adjustedSpread: number | null = null;
  if (hasCoinToss && edge !== 0) {
    adjustedSpread =
      firstPossession === 1
        ? roundToHalf(neutralSpread + edge) // receiver penalized if edge > 0
        : roundToHalf(neutralSpread - edge);
  }

  const adjustedDisplay =
    adjustedSpread !== null
      ? formatSpread(adjustedSpread, player1.name, player2.name)
      : null;

  const firstPlayer =
    firstPossession === 1 ? player1 : firstPossession === 2 ? player2 : null;

  return (
    <Card className="bg-gradient-to-r from-[#1b0f32] to-[#132654] border-0 overflow-hidden">
      <CardContent className="py-2 px-4">
        <div className="flex flex-col gap-2">
          <div className="flex items-center justify-center">
            <span className="text-[10px] uppercase tracking-wider text-white/50 font-medium">
              Pre-Game Lines
            </span>
          </div>

          <div className="grid grid-cols-3 gap-4 text-center">
            {/* Spread */}
            <div className="flex flex-col">
              <span className="text-[10px] uppercase tracking-wider text-white/40 mb-1">
                Spread
              </span>
              <div className="bg-black/30 rounded px-3 py-1.5">
                <span className="text-white font-bold text-sm">
                  {neutralDisplay}
                </span>
              </div>

              {adjustedDisplay && (
                <div className="mt-1 text-[9px] text-white/30">
                  After toss: {adjustedDisplay}
                </div>
              )}
            </div>

            {/* Moneyline */}
            <div className="flex flex-col">
              <span className="text-[10px] uppercase tracking-wider text-white/40 mb-1">
                Moneyline
              </span>
              <div className="bg-black/30 rounded px-3 py-1.5 flex justify-center gap-3">
                <div className="flex flex-col items-center">
                  <span className="text-[9px] text-white/50">
                    {player1.name.slice(0, 8)}
                  </span>
                  <span className="text-white font-bold text-sm">
                    {formatMoneyline(line.moneylineA)}
                  </span>
                </div>
                <div className="w-px bg-white/20" />
                <div className="flex flex-col items-center">
                  <span className="text-[9px] text-white/50">
                    {player2.name.slice(0, 8)}
                  </span>
                  <span className="text-white font-bold text-sm">
                    {formatMoneyline(line.moneylineB)}
                  </span>
                </div>
              </div>
            </div>

            {/* Total */}
            <div className="flex flex-col">
              <span className="text-[10px] uppercase tracking-wider text-white/40 mb-1">
                Total
              </span>
              <div className="bg-black/30 rounded px-3 py-1.5">
                <span className="text-white font-bold text-sm">
                  O/U {line.total}
                </span>
              </div>
            </div>
          </div>

          {hasCoinToss && edge !== 0 && firstPlayer && (
            <div className="flex items-center justify-center">
              <span className="text-[9px] text-white/30">
                {firstPlayer.name} receives first ({edge > 0 ? "-" : "+"}
                {Math.abs(edge).toFixed(2)} pts)
              </span>
            </div>
          )}
        </div>
      </CardContent>
    </Card>
  );
}